---
id: 2
title: create-api-implementation-plan
stage: plan
date: 2026-02-06
surface: agent
model: claude-opus-4-6
feature: rest-api-logic
branch: 001-rest-api-logic
user: Hp
command: /sp.plan RESTful API & Business Logic Implementation

target: fastapi-backend-architect agent with backend-skill
labels: ["api", "fastapi", "backend", "planning"]
links:
  spec: specs/001-rest-api-logic/spec.md
  ticket: null
  adr: null
  pr: null
---

# Prompt History Record: REST API Implementation Plan

## Command
```
/sp.plan RESTful API & Business Logic Implementation

target: fastapi-backend-architect agent with backend-skill
```

## Input Prompt
```
RESTful API & Business Logic Implementation

Create: FastAPI application architecture, endpoint specifications, Pydantic schema design, service-layer patterns.
Decisions needing documentation: API design choices, error handling strategies, and validation approaches.
Testing strategy: Endpoint functionality, security validation, and integration testing.

Technical details:
- Use the `fastapi-backend-architect` agent with `backend-skill` as the primary implementer.
- Integrate outputs from `jwt-auth-specialist` (P2-SPEC-1) and `neon-database-operator` (P2-SPEC-2).
- Follow spec-driven development: all code must be generated by Claude Code from specifications.

## Architecture Sketch

1.  **FastAPI Application Core**
    - Main app instance with CORS, middleware, and router registration.
    - API organized by resource (tasks) using `APIRouter`.

2.  **Schema Layer (Pydantic Models)**
    - Request schemas (`TaskCreate`, `TaskUpdate`) for input validation.
    - Response schemas (`TaskPublic`) for output serialization and documentation.

3.  **Service Layer (Business Logic)**
    - Functions that orchestrate authentication, validation, and repository calls.
    - Contains business rules and error handling specific to task operations.

4.  **Route Layer (REST Endpoints)**
    - Six endpoints implementing full CRUD + completion toggle.
    - All endpoints protected by JWT authentication dependency.
    - Path parameter validation for user security.

## Component Breakdown

### Phase 3A: Application Foundation & Schemas
- Initialize FastAPI app with CORS and settings.
- Define Pydantic schemas for task operations.
- Create API router structure.

### Phase 3B: Service Layer Implementation
- Build service functions that call task repository.
- Implement business logic for task operations.
- Create proper error handling and edge cases.

### Phase 3C: Route Implementation & Security
- Implement all six REST endpoints with proper HTTP methods.
- Integrate JWT authentication from `get_current_user`.
- Add path parameter validation to prevent user impersonation.

### Phase 3D: Integration & Documentation
- Test complete API flow with authenticated requests.
- Verify OpenAPI/Swagger documentation generation.
- Prepare for frontend consumption (P2-SPEC-4).

## Decisions Needing Documentation

| Decision | Options | Tradeoffs | Chosen Approach |
|----------|---------|-----------|-----------------|
| **Response Modeling** | Full ORM objects vs Custom Pydantic models | Convenience vs Control | Custom Pydantic models (hides internal fields, controls exposure) |
| **Error Handling** | FastAPI exceptions vs Custom exception handler | Consistency vs Granularity | FastAPI `HTTPException` with consistent JSON error format |
| **Path Parameter Security** | Manual validation vs Dependency injection | Explicit vs Reusable | Separate dependency `validate_user_path` that checks JWT `user_id` against path `user_id` |
| **Service vs Repository** | Thick repositories vs Thick services | Reusability vs Business logic encapsulation | Thin repositories (raw CRUD), Thick services (business rules, orchestration) |
| **API Versioning** | URL prefix vs Header-based | Simplicity vs Flexibility | URL prefix (`/api/v1/`) for hackathon simplicity |

## Testing Strategy

### Endpoint Functional Tests
- Each endpoint returns correct HTTP status codes (200, 201, 404, etc.).
- Request validation works (invalid data → 422 Unprocessable Entity).
- Response shapes match Pydantic schemas.

### Security Validation
- Unauthenticated requests → 401 Unauthorized.
- Wrong user accessing another's tasks → 403 Forbidden.
- Path parameter manipulation attempts are blocked.

### Integration Tests
- Complete flow: Auth → API call → Database operation.
- Data consistency across create/read/update/delete operations.
- Error scenarios handled gracefully.

## Technical Specifications

### Pydantic Schema Design
```python
# Request schemas (input validation)
class TaskCreate(BaseModel):
    title: str = Field(..., min_length=1, max_length=200)
    description: Optional[str] = Field(None, max_length=1000)

class TaskUpdate(BaseModel):
    title: Optional[str] = Field(None, min_length=1, max_length=200)
    description: Optional[str] = Field(None, max_length=1000)
    completed: Optional[bool] = None

# Response schema (output serialization)
class TaskPublic(BaseModel):
    id: int
    title: str
    description: Optional[str]
    completed: bool
    created_at: datetime
    updated_at: datetime

    class Config:
        from_attributes = True  # Enables ORM to Pydantic conversion
Endpoint Structure
text
GET    /api/{user_id}/tasks           # List all tasks for user
POST   /api/{user_id}/tasks           # Create new task
GET    /api/{user_id}/tasks/{task_id} # Get specific task
PUT    /api/{user_id}/tasks/{task_id} # Update full task
DELETE /api/{user_id}/tasks/{task_id} # Delete task
PATCH  /api/{user_id}/tasks/{task_id}/complete  # Toggle completion
Service Layer Pattern
python
# Example service function
def create_task_for_user(db: Session, user_id: str, task_data: TaskCreate):
    # Business logic here (e.g., validation, limits, notifications)
    # Call repository function
    return task_repository.create_task_for_user(db, user_id, task_data)
Integration Points
With P2-SPEC-1 (Authentication)
All endpoints use Depends(get_current_user).

Service layer receives verified user_id from JWT token.

Path parameter validation ensures JWT user_id matches path user_id.

With P2-SPEC-2 (Database)
Service functions call task_repository methods.

Database sessions provided via Depends(get_db) dependency.

Repository handles raw SQL operations, service handles business logic.

With P2-SPEC-4 (Frontend)
Clear API contract via Pydantic schemas.

Consistent error responses for frontend error handling.

CORS configured for frontend-backend communication.

Success Deliverables
Running FastAPI application with all six endpoints.

Complete OpenAPI/Swagger documentation at /docs.

All endpoints properly secured with JWT authentication.

User isolation verified: no cross-user data access.

Service layer with business logic separating routes from repositories.

Handoff readiness for P2-SPEC-4 (Frontend UI).

Risk Mitigation
Security breaches: Mandatory path parameter validation, dependency injection for auth.

Poor performance: Efficient query patterns, proper indexing in database.

API inconsistencies: Strict Pydantic schemas, consistent error responses.

Integration failures: Early testing with authentication and database layers.
```

## Response Snapshot

Successfully created a comprehensive implementation plan for the REST API & Business Logic feature. The plan includes:

### Architecture Components
- **FastAPI Application Core** with CORS and router registration
- **Schema Layer** with Pydantic models for request/response validation
- **Service Layer** for business logic orchestration
- **Route Layer** with six secured REST endpoints

### Key Decisions Documented
- Custom Pydantic models for response serialization (vs. ORM objects)
- FastAPI HTTPException for error handling (vs. custom handlers)
- Dependency injection for path parameter security (vs. manual validation)
- Thin repositories with thick services pattern
- URL prefix versioning for simplicity

### Security Implementation
- JWT token validation via `get_current_user` dependency
- Path parameter validation to ensure JWT user_id matches path user_id
- User data isolation through authentication and validation
- Protection against user impersonation attempts

### Integration Points
- With P2-SPEC-1: JWT authentication and user_id extraction
- With P2-SPEC-2: Database sessions and repository function calls
- With P2-SPEC-4: Clear API contracts and error handling for frontend

The plan follows all constitutional requirements including SDD-first approach, agentic specialization, clean architecture, and security-by-default principles. The implementation will be executed by the `fastapi-backend-architect` agent following the spec-driven development workflow.

## Outcome

### Impact
This plan enables the secure implementation of a full-featured REST API for the Todo application with proper user isolation and validation.

### Tests
The plan incorporates testing strategies for endpoint functionality, security validation, and integration scenarios to ensure proper implementation.

### Files Created
- `specs/001-rest-api-logic/plan.md` - Main implementation plan
- `specs/001-rest-api-logic/research.md` - Research summary with decision rationales
- `specs/001-rest-api-logic/data-model.md` - API schemas and endpoints specification
- `specs/001-rest-api-logic/quickstart.md` - Setup and usage guide
- `specs/001-rest-api-logic/contracts/api-contract.md` - Complete API contract
- Updated `CLAUDE.md` with new technologies

### Next Steps
1. Generate detailed tasks using `/sp.tasks` to break down implementation into specific items
2. Begin implementation using the `fastapi-backend-architect` agent with the `backend-skill`
3. Implement the API endpoints, schemas, and services following the contract specifications

### Reflection
The plan thoroughly addresses all requirements with special attention to the critical security rule of user isolation and path parameter validation.

## Evaluation Notes

The implementation plan comprehensively covers all aspects of the REST API development with strong emphasis on security, validation, and integration with existing components. The plan aligns with all constitutional requirements and sets up the project for successful completion by the specialized agents.